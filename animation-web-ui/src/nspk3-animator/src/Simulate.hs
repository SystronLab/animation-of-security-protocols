{- generated by Isabelle -}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TemplateHaskell #-}

module Simulate (simulate, ppAgent, ppMsg, ppSig, ppK, ppG, ppNmk, ppNonce, ppSet, ppList, ppTrace, ppTraceApp, format_events, 
  format_reach, simulate_cnt, eventList, eventTreeList, formatEvents, TEvent(..), TEventPos(..), EventTree(..), formatTEvent, formatTEvents, 
  explore_tree_cnt, getChannelList, getChannelList4Property 
  ) where
import Interaction_Trees;
import Prelude;
import Text.Read;
import Text.Show.Pretty;
import Data.Text as T (Text, pack)
-- import Data.Text.Encoding  as T
-- import Data.Text.IO        as T
-- import Partial_Fun;
import System.IO;
import Sec_Messages;
import qualified Data.List (dropWhile, dropWhileEnd, intersect, head, tail, elemIndex, uncons);
import Control.Monad (forM_, when);
import Data.Monoid (mempty, mappend);
import System.Exit (exitWith, ExitCode( ExitSuccess ));
-- import System.Random
import System.Random.Stateful;
import Data.Char (isSpace); 
import Arith (Nat(..))
import Set
import FSNat
import qualified Type_Length;
import GHC.Generics (Generic)

splitWhen :: (Char -> Bool) -> String -> [String]
splitWhen p s =  case Data.List.dropWhile p s of
   "" -> []
   s' -> w : splitWhen p s''
         where (w, s'') = Prelude.break p s'

splitOn c = splitWhen (== c)

deleteWhen             :: (a -> Bool) -> [a] -> [a]
deleteWhen _  []       = []
deleteWhen p (y:ys)    = if p y then ys else y : deleteWhen p ys

deleteBy                :: (a -> a -> Bool) -> a -> [a] -> [a]
deleteBy _  _ []        = []
deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys

-- It is not ideal to use this way [show event (prelude.show Chan)=> parse textual event (use read) => pattern match Chan] to pretty print channels
-- But I haven't figured out a way to customise show for Chan without removing 'Prelude.Show' in Chan's definition because it is automatically generated by Isabelle/HOL
--    deriving (Prelude.Read, Prelude.Show);
data ForPrint = FP String;

-- instance Show a => Show (ForPrint a) where 
--   show (FP x) = case (readMaybe x) of
--     Just (Env_C a)   -> "Env"
--     _           -> "Others"

printFP :: ForPrint -> String;
printFP (FP x) = case (read x) of 
  (Env_C (a, b)) -> "Env [" ++ ppAgent a ++ "] " ++ ppAgent b;
  (Send_C (a, (b, (c, d)))) -> "Send [" ++ ppAgent a ++ " -- " ++ ppAgent b ++ " --> " ++ ppAgent c ++ "] " ++ ppMsg d;
  (Recv_C (a, (b, (c, d)))) -> "Recv [" ++ ppAgent a ++ " -- " ++ ppAgent b ++ " --> " ++ ppAgent c ++ "] " ++ ppMsg d;
  (Leak_C d) -> "Leak " ++ ppMsg d ;
  (Sig_C d) -> "Sig " ++ ppSig d ;
  (Terminate_C _) -> "Terminate";

ppMsg :: Dmsg a b c d e f -> String
ppMsg (MAg a) = ppAgent a; 
ppMsg (MNon n) = ppNonce n;
ppMsg (MK k) = ppK k;
ppMsg (MPair m1 m2) = "<" ++ ppMsg m1 ++ ", " ++ ppMsg m2 ++ ">";
ppMsg (MAEnc m k) = ['{'] ++ ppMsg m ++ "}^a" ++ "_" ++ ppMsg k;
ppMsg (MSig m k) = ['{'] ++ ppMsg m ++ "}^d" ++ "_" ++ ppMsg k;
ppMsg (MSEnc m k) = ['{'] ++ ppMsg m ++ "}^s" ++ "_" ++ ppMsg k;
ppMsg (MExpg g) = ppG (MExpg g);
ppMsg (MModExp m e) = ppMsg m ++ ['^'] ++ ppMsg e;
ppMsg (MBitm bm) = ppMBitm (bm);
ppMsg (MWat m bm) = ['{'] ++ ppMsg m ++ "}^w" ++ "_" ++ ppMsg bm;
ppMsg (MJam m bm) = ['{'] ++ ppMsg m ++ "}^j" ++ "_" ++ ppMsg bm;

ppAgent (Agent (Nmk (Nat x))) = "A" ++ ppShow x;
ppAgent (Intruder) = "I";
ppAgent (Server) = "S";

ppNmk (Nmk (Nat x))  = ppShow x;

ppNonce n = "N" ++ ppNmk n;

ppK (Kp x) = "PK" ++ ppNmk x;
ppK (Ks x) = "SK" ++ ppNmk x;

ppG (MExpg g) = "g" ++ ppNmk g;

ppMBitm (Null) = "BMNull";
ppMBitm (Bm bm) = "BM"  ++ ppNmk bm;

ppSet (Set a) = (Prelude.foldl (\x y -> x ++ ppAgent y) "" a)
ppSet _ = ""

ppList a = (Prelude.foldl (\x y -> x ++ y) "" a)

ppSig :: Dsig a b -> String
ppSig (ClaimSecret a n d) = "CliamSecret " ++ "(" ++ ppAgent a ++ ") (" ++ ppNonce n ++ ") (" ++ ppSet d ++ ")";
ppSig (StartProt s d ns nd) = "StartProt " ++ "(" ++ ppAgent s ++ ") (" ++ ppAgent d ++ ") (" ++ ppNonce ns ++ ") (" ++ ppNonce nd ++ ")";
ppSig (EndProt s d ns nd) = "EndProt " ++ "(" ++ ppAgent s ++ ") (" ++ ppAgent d ++ ") (" ++ ppNonce ns ++ ") (" ++ ppNonce nd ++ ")";

data AutoCmd = Auto Int 
  | Rand Int 
  | AReach Int -- Chan -- check reachability of Event
  | RReach Int -- Chan -- check reachability of Event
  | Quit 
  | Manual 
  | Deadlock 
  | Feasible 
  deriving (Prelude.Read, Prelude.Show);

-- These library functions help us to trim the "_C" strings from pretty printed events

isPrefixOf              :: (Eq a) => [a] -> [a] -> Bool;
isPrefixOf [] _         =  True;
isPrefixOf _  []        =  False;
isPrefixOf (x:xs) (y:ys)=  x == y && Simulate.isPrefixOf xs ys;

removeSubstr :: String -> String -> String;
removeSubstr w "" = "";
removeSubstr w s@(c:cs) = (if w `Simulate.isPrefixOf` s then Prelude.drop (Prelude.length w) s else c : removeSubstr w cs);

showTrace :: (Prelude.Show e) => [e] -> String
showTrace [] = "" 
showTrace (t:ts) = (printFP (FP (Prelude.show t))) ++ ", " ++ showTrace ts;

ppTrace e = "[" ++ showTrace e ++ "]"
ppTraceApp e estr = "[" ++ showTrace e ++ estr ++ "]"

-- %er1;er2;...%
format_events :: String -> [String]
format_events ins = let
    r1 = deleteBy (==) '%' ins;
    r2 = deleteBy (==) '%' r1;
    rl = Simulate.splitOn ';' r2;
    rl1 = map (Data.List.dropWhile (isSpace)) rl;
    rl2 = map (Data.List.dropWhileEnd (isSpace)) rl1
  in rl2 

-- %er1;er2;...% # %em1;em2;...%
-- a list of events for reachability check and a list events for monitor only (so our search won't stop when encountering a monitor event)
format_reach :: String -> ([String], [String])
format_reach ins = 
  let rm = splitOn '#' ins
  in case Data.List.uncons rm of
    Nothing -> ([], []) 
    Just (re, tl) -> case Data.List.uncons tl of
      Nothing -> (format_events re, []) 
      Just (me, tl) -> (format_events re, format_events me)

{- simulate_cnt n P mod steps re me tr
  n: the maximum number of steps that internal events should be executed
  P: the process for animation
  mod: current automation mode
  steps: current no. of steps in automation 
  re: events for reachability check
  me: events for monitor 
  tr: the current trace 
-}
simulate_cnt :: (Eq e, Prelude.Show e, Prelude.Read e, Prelude.Show s) => Prelude.Int -> Itree e s -> AutoCmd -> Prelude.Int -> [String] -> [String] -> [e] -> Prelude.IO ();
simulate_cnt n (Ret x) mod steps re me tr = case mod of
  (AReach _) -> Prelude.putStr ""
  (RReach _) -> Prelude.putStr ""
  _ -> do {
    Prelude.putStrLn ("Successfully Terminated: " ++ Prelude.show x);
    Prelude.putStrLn ("Trace: " ++ (ppTrace tr)) 
  }
simulate_cnt n (Sil p) mod steps re me tr = 
  do { --if (n == 0) then Prelude.putStrLn "Internal Activity..." else return ();
       if (n >= 2000) then do { 
         Prelude.putStr "Many steps (> 2000); Continue? [Y/N]"; 
         q <- Prelude.getLine; 
         if (q == "Y") then simulate_cnt 0 p mod steps re me tr else Prelude.putStrLn "Ended early.";
       }
       else simulate_cnt (n + 1) p mod steps re me tr 
 }

simulate_cnt n (Vis (Pfun_of_alist [])) mod steps re me tr = case mod of
  (AReach _) -> Prelude.putStr "."
  (RReach _) -> Prelude.putStr "."
  _ -> do {
    Prelude.putStrLn "*** Deadlocked ***";
    Prelude.putStrLn ("Trace: " ++ (ppTrace tr))
  }

simulate_cnt n t@(Vis (Pfun_of_alist m)) mod steps re me tr = 
  do { 
      let 
        -- All available visible events, as string
        events = (map (\m -> printFP (FP (Prelude.show (fst m)))) m);
      in 
        do {
          case mod of
            (Auto x) -> if steps >= x then 
            -- switch to manual after specified steps
                do {
                  -- simulate_cnt n t Manual 0 tr
                  -- Prelude.putStrLn ("Auto [" ++ (show x) ++ "] Trace: " ++ (ppTrace tr)) 
                  -- return ()
                  Prelude.putStr ("-")
                } 
              else 
                do {
                  forM_ m $ \s -> simulate_cnt n (snd s) mod (steps+1) re me (tr ++ [fst s]) ;
                  when (steps == 0) (  Prelude.putStrLn ("*** Auto [" ++ (show x) ++ "] Finished ***") )
                  -- if (steps == 0) then 
                  --   do { Prelude.putStrLn ("*** Auto [" ++ (show x) ++ "] Finished ***") }
                  -- else
                  --   do { }
                }
            (Rand x) -> if steps >= x then 
            -- switch to manual after specified steps
                do {
                  -- simulate_cnt n t Manual 0 tr
                  -- Prelude.putStrLn ("Rand [" ++ (show x) ++ "] Trace: " ++ (ppTrace tr)) 
                  -- return ()
                  Prelude.putStr ("-")
                } 
              else 
                do {
                  -- if there is only one event, we don't need to choose
                  if (Prelude.length m == 1) 
                  then do { 
                    -- Prelude.putStrLn ("Random: only 1" ++ "> " ++  (Prelude.show (fst (m !! (0))))) ; 
                    simulate_cnt 0 (snd (m !! (0))) mod (steps + 1) re me (tr ++ [fst (m !! (0))]) 
                    }
                  else
                    do {
                      rn <- applyAtomicGen (uniformR (1 :: Int, Prelude.length m)) globalStdGen;
                      -- let (rn, newg) = uniformR (1 :: Int, Prelude.length m)
                      -- in 
                      do { 
                        -- Prelude.putStrLn ("Random chosen: " ++ show rn ++ "> " ++ (Prelude.show (fst (m !! (rn-1))))) ; 
                        simulate_cnt 0 (snd (m !! (rn-1))) mod (steps + 1) re me (tr ++ [fst (m !! (rn-1))])
                      }
                    }
                  ;
                  when (steps == 0) (  Prelude.putStrLn ("*** Random [" ++ (show x) ++ "] Finished ***") )
                }
            (AReach x) -> if steps >= x then 
                do {
                  -- Prelude.putStrLn ("Auto Reachability [" ++ (show x) ++ "] Trace: " ++ (ppTrace tr)) 
                  -- return ()
                  Prelude.putStr ("-")
                } 
              else 
                do {
                  -- these are events reached now
                  let reached = ppList (Data.List.intersect events re);
                      monitored = Data.List.intersect events me;
                    in if reached /= [] then do {
                      Prelude.putStrLn ("*** These events [" ++ reached ++ "] are reached! ***" ++ "\nTrace: " ++ (ppTraceApp tr reached));
                      Prelude.putStrLn ("");
                    }
                    else do {
                      if monitored /= [] then 
                        Prelude.putStrLn ("*** These events " ++  show monitored ++ " are monitored! ***");
                      else 
                        Prelude.putStr ("");
                      forM_ m $ \s -> simulate_cnt n (snd s) mod (steps+1) re me (tr ++ [fst s]) ;
                      when (steps == 0) (  Prelude.putStrLn ("*** Auto Reachability [" ++ (show x) ++ "] Finished ***") )
                    }
                }
            (RReach x) -> if steps >= x then 
            -- switch to manual after specified steps
                do {
                  -- Prelude.putStrLn ("Random Reachability [" ++ (show x) ++ "] Trace: " ++ (ppTrace tr)) 
                  -- return ()
                  Prelude.putStr ("-")
                } 
              else 
                do {
                  -- these are events reached now
                  let reached = ppList (Data.List.intersect events re);
                      monitored = Data.List.intersect events me;
                    in if reached /= [] then do {
                      Prelude.putStrLn ("*** These events [" ++ reached ++ "] are reached! ***" ++ "\nTrace: " ++ (ppTraceApp tr reached));
                      Prelude.putStrLn ("");
                    }
                    else do {
                       if monitored /= [] then 
                        Prelude.putStrLn ("*** These events " ++  show monitored ++ " are monitored! ***");
                      else 
                        Prelude.putStr ("");

                      -- if there is only one event, we don't need to choose
                      if (Prelude.length m == 1) 
                      then do { 
                        -- Prelude.putStrLn ("Reachability Random: only 1" ++ "> " ++  (Prelude.show (fst (m !! (0))))) ; 
                        simulate_cnt 0 (snd (m !! (0))) mod (steps + 1) re me (tr ++ [fst (m !! (0))]) 
                        }
                      else
                        do {
                          rn <- applyAtomicGen (uniformR (1 :: Int, Prelude.length m)) globalStdGen;
                          -- let (rn, newg) = uniformR (1 :: Int, Prelude.length m)
                          -- in 
                          do { 
                            -- Prelude.putStrLn ("Random chosen: " ++ show rn ++ "> " ++ (Prelude.show (fst (m !! (rn-1))))) ; 
                            simulate_cnt 0 (snd (m !! (rn-1))) mod (steps + 1) re me (tr ++ [fst (m !! (rn-1))])
                          }
                        }
                      ;
                      when (steps == 0) (  Prelude.putStrLn ("*** Random Reachability [" ++ (show x) ++ "] Finished ***") )
                    }
                }
            (Feasible) -> case Data.List.uncons re of
              Nothing -> do {Prelude.putStrLn ("*** The specified trace is feasible ****")}
              Just (hd, tl) -> -- in if cur_event_to_check `elem` events then
                  case Data.List.elemIndex hd events of
                    Just rn -> do {
                      simulate_cnt 0 (snd (m !! (rn))) mod (steps + 1) tl me (tr ++ [fst (m !! (rn))])
                    }
                    Nothing -> do {Prelude.putStrLn ("*** Event [" ++ hd ++ "] is not feasible in current state \nwhere feasible events include \t" ++ show events)}
                
            (Quit) -> Prelude.putStrLn "Simulation terminated";
            (Manual) -> do { 
              -- Manual
                 Prelude.putStrLn ("Events:\n" ++ Prelude.concat (map (\(n, e) -> " (" ++ ppShow n ++ ") " ++ removeSubstr "_C" e ++ ";\n") (zip [1..] events)));
                 -- Prelude.putStrLn ("Events:\n" ++ Prelude.concat (map (\(n, e) -> " (" ++ ppShow n ++ ") " ++ removeSubstr "_C" e ++ ";\n") (zip [1..] (map (\m -> (Prelude.show (fst m))) m))));
                 Prelude.putStr ("[Choose: 1-" ++ Prelude.show (Prelude.length m) ++ "]: ");
                 e <- Prelude.getLine;
                 
                 do {
                  -- try to parse AutoCmd 
                  case (Prelude.reads e)::[(AutoCmd, String)] of
                    []       -> do { 
                      -- Prelude.putStrLn "Not AutoCmd, use Manual";
                      -- Other commands
                      if (e == "q" || e == "Q") then
                        do {
                            Prelude.putStrLn ("*** Simulation terminated ***"); 
                            Prelude.putStrLn ("Trace: " ++ (ppTrace tr));
                            System.Exit.exitWith System.Exit.ExitSuccess
                        }
                      else if (e == "h" || e == "H") then
                        do {
                            Prelude.putStrLn ("*** Usage ***"); 
                            Prelude.putStrLn ("Auto n : Exhaustive search of traces up to n events or length;");
                            Prelude.putStrLn ("Rand n : Random search of a trace up to n events or length;");
                            Prelude.putStrLn ("AReach n %er1;er2;...%[#%em1;em2;...%] : Exhaustive search of traces up to n events or length, or if the specified events (er) are reached with optional events for monitor (em);");
                            Prelude.putStrLn ("RReach n %er1;er2;...%[#%em1;em2;...%] : Random search of a trace up to n events or length, or if the specified events (er) are reached with optional events for monitor (em);");
                            Prelude.putStrLn ("Feasible %event1;event2;...% : Check whether the specified sequence of events is a feasible trace from current state.\n");
                            -- System.Exit.exitWith System.Exit.ExitSuccess
                            simulate_cnt n t mod steps re me tr 
                        }
                      else
                        case (Prelude.reads e) of
                          []       -> if (Prelude.length m == 1)
                                        then do { Prelude.putStrLn ( (Prelude.show (fst (m !! 0)))) ; simulate_cnt 0 (snd (m !! (0))) mod steps re me (tr ++ [fst (m !! 0)]) }
                                        else do { Prelude.putStrLn "No parse"; simulate_cnt n t mod steps re me tr }
                          [(v, _)] -> if (v > Prelude.length m)
                                        then do { Prelude.putStrLn "Rejected"; simulate_cnt n t mod steps re me tr }
                                        else do { Prelude.putStrLn ( (Prelude.show (fst (m !! (v-1))))) ; simulate_cnt 0 (snd (m !! (v - 1))) mod steps re me (tr ++ [fst (m !! (v-1))]) }

                      }
                    -- parsed AutoCmd where r is the rest string after a, parsed AutoCmd 
                    [(a, r)] -> do {
                      Prelude.putStrLn (show a ++ ", " ++ r);
                      case a of 
                        (Auto x) ->  do { -- Prelude.putStrLn ("Auto " ++ show x); 
                            simulate_cnt n t a 0 [] [] tr }
                        (Rand x) ->  do { -- Prelude.putStrLn ("Random " ++ show x); 
                            simulate_cnt n t a 0 [] [] tr }
                        (AReach x) ->  do {
                          let (res,mes) = format_reach r
                          in do {
                            Prelude.putStrLn ("Reachability by Auto: " ++ show x ++ "\n  Events for reachability check: " ++ show res ++ "\n  Events for monitor: " ++ show mes); 
                            simulate_cnt n t a 0 res mes tr 
                          }
                        }
                        (RReach x) ->  do {
                          let (res,mes) = format_reach r
                          in do {
                            Prelude.putStrLn ("Reachability by Random: " ++ show x ++ "\n  Events for reachability check: " ++ show res ++ "\n  Events for monitor: " ++ show mes); 
                            simulate_cnt n t a 0 res mes tr 
                          }
                        }
                        (Feasible) ->  do {
                          let fe = format_events r
                          in do {
                            Prelude.putStrLn ("Feasibility check the sequence of events: " ++ show fe); simulate_cnt n t a 0 fe me tr 
                          }
                        }
                        (Quit) -> do {
                            Prelude.putStrLn ("*** Simulation terminated ***"); 
                            Prelude.putStrLn ("Trace: " ++ (ppTrace tr));
                            System.Exit.exitWith System.Exit.ExitSuccess
                        }
                        _ -> do {Prelude.putStrLn ("Unknown " ++ show a)}
                      }
                  }
              }
         }
         
--       if (e == "q" || e == "Q") then
--         Prelude.putStrLn "Simulation terminated"
--       else
--        case (Prelude.reads e) of
--          []       -> if (Prelude.length m == 1)
--                        then do { Prelude.putStrLn ( (Prelude.show (fst (m !! 0)))) ; simulate_cnt 0 (snd (m !! (0)))}
--                        else do { Prelude.putStrLn "No parse"; simulate_cnt n t }
--          [(v, _)] -> if (v > Prelude.length m)
--                        then do { Prelude.putStrLn "Rejected"; simulate_cnt n t }
--                        else do { Prelude.putStrLn ( (Prelude.show (fst (m !! (v-1))))) ; simulate_cnt 0 (snd (m !! (v - 1)))}
     };
simulate_cnt n t@(Vis (Pfun_of_map f)) mod steps re me tr = 
  do { Prelude.putStr ("Enter an event:");
       e <- Prelude.getLine;
       if (e == "q" || e == "Q") then
         Prelude.putStrLn "Simulation terminated"
       else
       case (Prelude.reads e) of
         []       -> do { Prelude.putStrLn "No parse"; simulate_cnt n t mod steps re me tr } 
         [(v, _)] -> case f v of
                       Nothing -> do { Prelude.putStrLn "Rejected"; simulate_cnt n t mod steps re me tr }
                       Just t' -> simulate_cnt 0 t' mod steps re me tr 
     };                                                                

simulate :: (Eq e, Prelude.Show e, Prelude.Read e, Prelude.Show s) => Itree e s -> Prelude.IO ();
simulate p = do { hSetBuffering stdout NoBuffering; putStrLn ""; putStrLn "Starting ITree Animation..."; simulate_cnt 0 p (Manual) 0 [] [] []}

eventList :: (Eq e, Prelude.Show e, Prelude.Read e, Prelude.Show s) => Itree e s -> Maybe [e];
eventList (Ret x) = Nothing 
eventList (Sil p) = eventList p 
eventList t@(Vis (Pfun_of_alist [])) = Just [] 
eventList t@(Vis (Pfun_of_alist m)) = Just $ map fst m 
eventList t@(Vis (Pfun_of_map f)) = error "Not supported Pfun_of_map" 

eventTreeList :: (Eq e, Prelude.Show e, Prelude.Read e, Prelude.Show s) => Itree e s -> Maybe [(e, Itree e s)];
eventTreeList (Ret x) = Nothing 
eventTreeList (Sil p) = eventTreeList p 
eventTreeList t@(Vis (Pfun_of_alist [])) = Just [] 
eventTreeList t@(Vis (Pfun_of_alist m)) = Just $ m 
eventTreeList t@(Vis (Pfun_of_map f)) = error "Not supported Pfun_of_map" 

formatEvents :: (Chan a b c d e f) -> (String, String, String, String, String); 
formatEvents (Env_C (a, b)) = ("Env", "Env", "Env", ppAgent a, ppAgent b); 
formatEvents (Send_C (a, (b, (c, d)))) = ("Send", ppAgent a, ppAgent b, ppAgent c, ppMsg d); 
formatEvents (Recv_C (a, (b, (c, d)))) = ("Recv", ppAgent a, ppAgent b, ppAgent c, ppMsg d); 
formatEvents (Leak_C d) = ("Leak", "Intruder", "Intruder", "Env", ppMsg d); 
formatEvents (Sig_C s) = case s of 
  (ClaimSecret a n d) -> case d of 
    Set.Set [x] -> ("[Sig]ClaimSecret", ppAgent a, ppAgent a, ppAgent x, ppNonce n); 
    _ -> ("[Sig]ClaimSecret", ppAgent a, ppAgent a,"", ppNonce n); 
  (StartProt s d ns nd) -> ("[Sig]StartProt", ppAgent s, ppAgent s, ppAgent d, ppNonce ns ++ "/" ++ ppNonce nd); 
  (EndProt s d ns nd) -> ("[Sig]EndProt", ppAgent s, ppAgent s, ppAgent d, ppNonce ns ++ "/" ++ ppNonce nd); 
formatEvents (Terminate_C _) = ("Terminate", "Sys", "Sys", "Env", "");

animate_manual :: (Eq e, Prelude.Show e, Prelude.Read e, Prelude.Show s) => Itree e s -> e -> (String, Maybe (Itree e s)); 
animate_manual (Ret x) e = ("Terminated. ",  Nothing)
animate_manual (Sil p) e = (animate_manual p e)
animate_manual t@(Vis (Pfun_of_alist [])) e = ("Deadlocked. ", Nothing) 
animate_manual t@(Vis (Pfun_of_alist m)) e = 
  if (e `elem` map fst m) then 
    ("event" ++ (Prelude.show e) ++ " animated. ", Just $ pfun_app (Pfun_of_alist m) e) 
  else 
    ("Not enabled event " ++ (Prelude.show e) ++ ". ", Just t)

-- | Tree Event
-- Root: the root of the tree
-- Deadlocked: deadlocked state
-- Terminated: terminated state
-- Divergence: divergence after some fixed tau steps
-- EChan: Chan event 
data TEvent a b c d e f = Root | Deadlocked | Terminated | Divergent | EChan (Sec_Messages.Chan a b c d e f) 
  deriving (Eq, Read, Show, Generic)

-- | Tree Event with its position 
-- TEP: an event with its depth and event numbering in that depth (to uniquely identify the event in the tree) 
data TEventPos a b c d e f = TEP Int Int (TEvent a b c d e f)
  deriving (Eq, Read, Show, Generic)

-- | Event tree
data EventTree a b c d e f = ETNode (TEventPos a b c d e f) [EventTree a b c d e f] 
  deriving (Eq, Read, Show, Generic)

-- | Format a tree event to text
formatTEvent :: TEvent a b c d e f -> Text
formatTEvent e = case e of 
  Root -> T.pack $ "ROOT"
  Deadlocked -> T.pack $ "Deadlocked"
  Terminated -> T.pack $ "Terminated"
  Divergent -> T.pack $ "Divergent"
  EChan e -> let (ch, src, medium, desc, msg) = formatEvents e in 
    (T.pack $ ch) <> (T.pack ":") <> (T.pack $ msg)

-- | Format a list of tree events to text
formatTEvents :: [TEvent a b c d e f] -> Text
formatTEvents [] = T.pack $ ""
formatTEvents (x:xs) = formatTEvent x <> (T.pack "; ") <> formatTEvents xs

-- | A function to exhaustively explore an ITree for given steps and 
-- steps: the maximum number of steps that external events should be executed 
-- cur_step: the current number of steps that external events have been executed 
-- tau_steps: the maximum number of steps that internal events should be executed 
-- cur_tau_step: the current number of steps that internal events have been executed 
explore_tree_cnt :: (Prelude.Show s) => forall a b c d e f. Itree (Chan a b c d e f) s -> Int -> Int -> Int -> Int -> [EventTree a b c d e f]; 
explore_tree_cnt (Ret x) steps cur_step tau_steps cur_tau_step = [ETNode (TEP cur_step 0 Terminated) []] 
explore_tree_cnt (Sil p) steps cur_step tau_steps cur_tau_step = 
  if cur_tau_step == 0 then [ETNode (TEP cur_step 0 Divergent) []] else (explore_tree_cnt p steps cur_step tau_steps (cur_tau_step - 1))
explore_tree_cnt t@(Vis (Pfun_of_alist [])) steps cur_step tau_steps cur_tau_step = [ETNode (TEP cur_step 0 Deadlocked) []]
explore_tree_cnt t@(Vis (Pfun_of_alist m)) steps cur_step tau_steps cur_tau_step = if cur_step < steps then 
    map (\(i, (e, etree)) -> ETNode (TEP cur_step i (EChan e)) (explore_tree_cnt etree (steps) (cur_step + 1) tau_steps tau_steps)) (zip [(1::Int)..] m) 
  else []
explore_tree_cnt t@(Vis (Pfun_of_map f)) steps cur_step tau_steps cur_tau_step = error "Not supported Pfun_of_map"
explore_tree_cnt t@(Vis (Pfun_entries _ _)) steps cur_step tau_steps cur_tau_step = error "Not supported Pfun_entries"

-- | Get the list of channels 
getChannelList :: [String]
getChannelList = ["Send", "Recv", "Hear", "Fake", "Leak", "[Sig]ClaimSecret", "[Sig]StartProt", "[Sig]EndProt", "Terminate"]

-- | Get the list of channels for property checking 
getChannelList4Property :: [String]
getChannelList4Property = ["Leak", "[Sig]ClaimSecret", "[Sig]StartProt", "[Sig]EndProt", "Terminate", "Deadlocked", "Divergent"]
